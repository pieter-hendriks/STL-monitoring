from .signal import Signal
from typing import List, Tuple
from .signalvalue import SignalValue
from ..utility import Interval

def booleanize(value: float):
	return 1 if value > 0 else 0

# TODO: Verify if there are any other behavioural differences.
# For example, in quantitative, we might interpolate the value of signal between
# checkpoints, this is undesirable for the boolean case, most likely.
class BooleanSignal(Signal):
	# BooleanSignal is a special case of a signal, with an additional requirement on the values (only 1 (T) or 0 (F) allowed)
	# There's a few algorithmic differences as well; these will be handled in the algorithm functions.
	def __init__(self, name: str = None, times: List[float] = None, values: List[float] = None, derivatives: List[float] = None) -> None:
		if values and not all([x == 1 or x == 0 for x in values]):
			newValues = [booleanize(x) for x in values]
			#warnings.warn(f"Booleanized a non-Boolean value list in the BooleanSignal class:\n\t{values}\n\t==>\n\t{newValues}\nValue <= 0 is considered False in this conversion.")
			values = newValues
		assert derivatives is None or all([x == 0 for x in derivatives]), f"Boolean signal initialized with non-zero derivative values: {derivatives}"
		# In case of empty signal, fill empty lists + dummy name
		if name is None:
			name = "autogeneratedBoolean"
			assert times is None and values is None and derivatives is None
			times, values, derivatives = [], [], []
		if values is None:
			values = []
		else:
			assert times is not None, "DEBUG ASSERT: have to autogenerate timestamps"
		if times is None:
			times = []
		else:
			assert values is not None, "We can't autogenerate values for times."
		if derivatives is None:
				# Set derivative to all zeroes, since it's not meaningful for a Boolean signal
				derivatives = [0] * len(times)
		# We don't necessarily fill in all None-valued arguments. The super class (Signal) will take care of this for us.
		super().__init__(name, times, values, derivatives)
	
	def emplaceCheckpoint(self, time: float, value: float, derivative: float = None) -> None:
		# Booleanize the value
		if value not in [1, 0]:
			value = booleanize(value)
		# Add the checkpoint to the list. In BooleanSignal, derivative is always 0.
		self.checkpoints.add(SignalValue(time, value, 0))
	
	def recomputeDerivatives(self):
		for cp in self.checkpoints:
			cp.setDerivative(0)

	def computeInterpolatedDerivative(self, t: float) -> float:
		return 0

	def computeInterpolatedValue(self, t: float) -> float:
		i: int = self.computeIndexForLargestTimeBefore(t)
		return self.getValue(i)

	@classmethod
	def fromSignal(cls, s: Signal):
		# Get the components of the original Signal
		if not s.checkpoints:
			# If it's empty, return empty boolean
			return cls(s.getName())
		times, values, derivatives = zip(*[(cp.getTime(), cp.getValue(), cp.getDerivative()) for cp in s.checkpoints])
		# Drop the derivatives, BooleanSignal doesn't use those.
		return cls(s.getName(), times, values, [0] * len(derivatives))

	@classmethod
	def computeComparableSignals(cls, lhs: 'BooleanSignal', rhs: 'BooleanSignal') -> Tuple['BooleanSignal', 'BooleanSignal']:
		lhs, rhs = BooleanSignal.computeCheckpointsForComparableSignal(lhs, rhs)
		return lhs, rhs
