""" Implementation of the BooleanSignal for the STL implementation """
from typing import List, Tuple
from .signal import Signal
from .signalvalue import SignalValue


def booleanize(value: float):
	""" Convert a given floating point value to its equivalent Boolean (1 if v > 0 else 0) """
	return 1 if value > 0 else 0


class BooleanSignal(Signal):
	""" BooleanSignal is a special case of a signal,
	with an additional requirement on the values (only 1 (T) or 0 (F) allowed)
	There's a few algorithmic differences as well;
	these will be handled in the algorithm functions. """

	def __init__(
	    self,
	    name: str = None,
	    times: List[float] = None,
	    values: List[float] = None,
	    derivatives: List[float] = None
	) -> None:
		# We don't necessarily fill in all None-valued arguments. The super class (Signal) will take care of this for us.
		super().__init__(name, times, values, derivatives)
		for cp in self.checkpoints:
			cp.setValue(booleanize(cp.getValue()))
			cp.setDerivative(0)

		# In case of empty signal, fill empty lists + dummy name
		if name is None:
			self.setName("autogeneratedBoolean")

	def emplaceCheckpoint(self, time: float, value: float, derivative: float = None) -> None:
		# Booleanize the value
		if value not in [1, 0]:
			value = booleanize(value)
		# Add the checkpoint to the list. In BooleanSignal, derivative is always 0.
		self.checkpoints.add(SignalValue(time, value, 0))
		self.times.add(time)

	def recomputeDerivatives(self):
		for cp in self.checkpoints:
			cp.setDerivative(0)

	def computeInterpolatedDerivative(self, t: float) -> float:
		return 0

	def computeInterpolatedValue(self, t: float) -> float:
		i: int = self.computeIndexForLargestTimeBefore(t)
		return self.getValue(i)

	@classmethod
	def fromSignal(cls, s: Signal):
		""" Construct a Boolean Signal from a different Signal. """
		# Get the components of the original Signal
		if not s.checkpoints:
			# If it's empty, return empty boolean
			return cls(s.getName())
		times, values, derivatives = zip(*[(cp.getTime(), cp.getValue(), cp.getDerivative()) for cp in s.checkpoints])
		# Drop the derivatives, BooleanSignal doesn't use those.
		return cls(s.getName(), times, values, [0] * len(derivatives))

	@classmethod
	def computeComparableSignals(cls, lhsSignal: 'BooleanSignal',
	                             rhsSignal: 'BooleanSignal') -> Tuple['BooleanSignal', 'BooleanSignal']:
		return BooleanSignal.computeCheckpointsForComparableSignal(lhsSignal, rhsSignal)

	def __repr__(self):
		return f"Boolean{super().__repr__()}"

	def __str__(self):
		return f"Boolean{super().__repr__()}"
