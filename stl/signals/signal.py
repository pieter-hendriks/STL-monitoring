from .signalvalue import SignalValue
from typing import List, Tuple
from ..utility import Interval, LineSegment, Point
import math
import warnings
from sortedcontainers import SortedList

class Signal:
	def __init__(self, name: str = None, times: List[float] = None, values: List[float] = None, derivatives: List[float] = None):
		""" Initializes a Signal. Name is autogenerated if not given. Set of times must be sorted in ascending order and must not contain duplicates. """
		# Ensure that name is valid (a string or None)
		if name is not None and type(name) != str:
			raise RuntimeError(f"Name argument is {type(name)} (value = {name}) instead of str")
		elif name is None:
			name: str = "defaultname"
		self.name: str = name
		# If no parameters given, construct a Signal('defaultname', [], [], [])
		if all([times is None, values is None, derivatives is None]):
			self.checkpoints: SortedList[SignalValue] = SortedList([], key = lambda x: x.getTime())
			return

		# Check that all times are unequal -- if times is not given in ascending order, bugs may appear.
		if times is not None:
			assert values is not None, "We can't autocompute values."
			assert all([times[i] != times[i+1] for i in range(len(times) - 1)]), "debug assert: times mustn't be equal"
		elif values is not None:
			# This shouldn't be reached in our usual cases - autogenerating timestamps seems weird.
			assert False, "DEBUG STATEMENT: May need to autogenerate timestamps here."
		# Set the variables to avoid errors in initialization
		safeTime = times if times is not None else list(range(len(values))) # Times are autogenerated to index of value if none given
		safeValue = values if values is not None else [] # If no values, the result should be empty signal 
		safeDeriv = derivatives if derivatives is not None else [0] * len(values)
		# Initialize
		self.checkpoints: SortedList[SignalValue] = SortedList([SignalValue(x, y, d) for x, y, d in zip(safeTime, safeValue, safeDeriv)], key = lambda x: x.getTime())
		# If derivatives weren't given, autocompute them.
		if derivatives is None:
			self.recomputeDerivatives()

	@classmethod
	def createConstant(cls, name: str, value: float, timestamps: List[float]) -> 'Signal':
		""" Create a constant Signal. """
		s = cls(name, timestamps, [value] * len(timestamps), [0] * len(timestamps))
		return s

	# We type-hint s as 'Signal' to avoid circular import
	# It should be BooleanSignal, in principle. But in effect, this method would work equally well from another Signal.
	@classmethod
	def fromBooleanSignal(cls, s: 'Signal') -> 'Signal':
		""" Conversion from a Boolean Signal. """
		if not s.checkpoints:
			return cls(s.getName())
		times, values, derivatives = zip(*[(cp.getTime(), cp.getValue(), cp.getDerivative()) for cp in s.checkpoints])
		newSignal = cls(s.getName(), times, values, derivatives)
		# Since we convert from Boolean, compute the derivatives.
		newSignal.recomputeDerivatives()
		return newSignal

	@classmethod
	def fromCheckpoints(cls, name: str, checkpoints: List[SignalValue]) -> 'Signal':
		""" Constructs a Signal instance from a list of checkpoints. Useful for copying. """
		s = cls(name)
		s.checkpoints = SortedList(checkpoints, key=lambda x: x.getTime())
		return s

	@classmethod
	def computeCheckpointsForComparableSignal(cls, lhsSignal: 'Signal', rhsSignal: 'Signal') -> Tuple['Signal', 'Signal']:
		""" Gets the checkpoints (sample points) with timestamps from either Signal (computing interpolated value for the other Signal when necessary)
		where the timestamps fall within the Interval in which both signals are defined (i.e. intersect(lhsInterval,)). """
		# These may be Signal or BooleanSignal; annotated Signal because BooleanSignal is a subclass
		lhsResult: Signal = cls("lhs"); rhsResult: Signal = cls('rhs')
		cp: SignalValue
		if not lhsSignal.getTimes() or not rhsSignal.getTimes():
			# If either signal is empty, the intersection is empty
			return lhsResult, rhsResult
		bothDefinedInterval: Interval = Interval.computeIntersection(lhsSignal.getDefinedTimeInterval(), rhsSignal.getDefinedTimeInterval())
		for cp in lhsSignal.getCheckpoints():
			if bothDefinedInterval.contains(cp.getTime()):
				lhsResult.addCheckpoint(cp)
				rhsResult.emplaceCheckpoint(cp.getTime(), rhsSignal.computeInterpolatedValue(cp.getTime()), rhsSignal.computeInterpolatedDerivative(cp.getTime()))
		for cp in rhsSignal.getCheckpoints():
			# Avoid double entries by checking if the given time is already in the result.
			if bothDefinedInterval.contains(cp.getTime()) and cp.getTime() not in rhsResult.getTimes():
				rhsResult.addCheckpoint(cp)
				lhsResult.emplaceCheckpoint(cp.getTime(), lhsSignal.computeInterpolatedValue(cp.getTime()), lhsSignal.computeInterpolatedDerivative(cp.getTime()))
		return lhsResult, rhsResult

	@classmethod
	def computeComparableSignals(cls, lhsSignal: 'Signal', rhsSignal: 'Signal') -> List['Signal']: 
		""" Create Signals that are comparable - this requires both Signals having the same sample point timings.\n
		First, we take all sample points from both Signals where the time values are identical.\n
		Second, we compute all points where, based on the derivative, the Signals intersect. \n
		Returns two Signals with an equal amount of sample points, where the time part of each sample point pair is equal."""

		# Get the sampling points where self and other are a) both defined or b) intersect
		# So, any time x where x in self.times() and x in other.times()
		# + any time y where, through the derivatives, we know that self.value(x) == other.value(x), assuming interpolation.
		assert type(lhsSignal) == type(rhsSignal), "Operation is unsupported between signals of different semantics."
		cls = type(lhsSignal)
		lhsResult: Signal = cls('empty'); rhsResult: Signal = cls('empty')
		if lhsSignal.isEmpty() or rhsSignal.isEmpty():
			return [lhsResult, rhsResult]
		# We build the sequence (ri)iâ‰¤nz containing the sampling points of y and y' when they are both defined, and the points where y and y' punctually intersect
		# First, we get the sampling points from the signals where they are both defined (i.e. all sample points with t1==t2)
		lhsResult, rhsResult = cls.computeCheckpointsForComparableSignal(lhsSignal, rhsSignal)
		# Second, we get the intersection points
		if not lhsResult.isEmpty() and not rhsResult.isEmpty():
			lhsLines: List[LineSegment] = lhsResult.computeLines()
			rhsLines: List[LineSegment] = rhsResult.computeLines()
			intersectPoints: List[Point] = LineSegment.computeIntersectionPoints(lhsLines, rhsLines)
			for point in intersectPoints:
				if point.x not in lhsResult.getTimes():
					lhsResult.emplaceCheckpoint(point.x, point.y, 0)
					rhsResult.emplaceCheckpoint(point.x, point.y, 0)
				else:
					assert math.isclose(lhsResult.getValue(lhsResult.computeIndexForTime(point.x)), point.y, rel_tol=1e-7), "Attempted to insert a duplicate point, with different values."
					assert math.isclose(rhsResult.getValue(rhsResult.computeIndexForTime(point.x)), point.y, rel_tol=1e-7), "Attempted to insert a duplicate point, with different values."
		lhsResult.recomputeDerivatives()
		rhsResult.recomputeDerivatives()
		assert lhsResult.getTimes() == rhsResult.getTimes(), "The punctual intersection function must return two Signals with exactly equal time checkpoints."
		return [lhsResult, rhsResult]


	def computeInterpolatedCheckpoint(self, t: float) -> SignalValue:
		"""Compute an interpolated checkpoint for the specified time"""
		return SignalValue(t, self.computeInterpolatedValue(t), self.computeInterpolatedDerivative(t))

	# Get the value of a signal at time step t
	def computeInterpolatedValue(self, t: float) -> float:
		"""Compute an interpolated value for the specified time"""
		ret: float = None
		# Mirror Efficient Robustness paper implementation: 
		# A signal value outside of the defined range of the Signal is undefined -- we crash here to avoid undefined behaviour
		if not self.getTimes() or not self.getDefinedTimeInterval().contains(t, closed=True):
			raise RuntimeError("Value outside of defined interval")
		i = 0
		# If it's within known values, find the correct time step
		while self.getTime(i) < t:
			i += 1
		if i == 0 or self.getTime(i) == t:
			# If point before signal started, return first data point
			# If it's an exact data point in the signal, return corresponding value
			ret =  self.getValue(i)
		elif i >= self.getCheckpointCount():
			# If it's after the end of signal, return last data point
			ret =  self.getValue(-1)
		else:
			# If it's somewhere between two data points, interpolate
			value = self.getValue(i - 1)
			value += (self.getValue(i) - self.getValue(i-1)) / ((self.getTime(i) - self.getTime(i-1)) * t - self.getTime(i-1))
			ret = value	# Get the value of a signal at time step t
		return ret

	# Get a derivative of the signal at time step t
	def computeInterpolatedDerivative(self, t: float) -> float:
		"""Compute an interpolated derivative for the specified time.\n
		Following the finite, piecewise, linear, continuous hypothesis, 
		this returns the derivative between the values (in self.getTimes()) that t is located between."""
		if t < self.getTime(0):
			warnings.warn("Got derivative before start of signal.")
			return 0
		if t > self.getTime(-1):
			return self.getDerivative(-1)
		for i in range(self.getCheckpointCount()):
			if t <= self.getTime(i):
				# Signal is linearly interpolated between points, so derivative is constant on the interval [i-1, i)
				return self.getDerivative(i-1)


	def computeInterval(self, interval: Interval, half_open: bool = False) -> 'Signal':
		""" Find the part of the signal that fits within the specified interval (endpoint inclusion based on value of 'half_open') """
		constructedSignalName = f"{self.getName()}_interval"
		signalType = type(self)
		output: 'Signal' = signalType(constructedSignalName)
		# Handle cases where lower bound is larger or equal to biggest values in the Signal.
		if interval.getLower() > self.getLargestTime():
			return output
		elif interval.getLower() == self.getLargestTime():
			output.addCheckpoint(self.checkpoints[-1])
			return output
		# Consider trivial interval case:
		if interval.getUpper() == interval.getLower():
			if not half_open:
				output.addCheckpoint(self.computeInterpolatedCheckpoint(interval.getLower()))
			return output
		# A valid index in the Signal, where timestamp is as close as possible to (but never smaller than) the lower bound of the interval
		lowerBoundIndex = self.computeIndexForSmallestTimeAfter(interval.getLower(), inclusive=True)
		# A valid index in the Signal, where timestamp is as close as possible to (but never larger than or equal to) the upper bound of the interval
		upperBoundIndex = self.computeIndexForLargestTimeBefore(interval.getUpper(), not half_open)

		# Get the output Signal. It might be missing up to two values still: one at interval.getLower() and one at interval.getUpper()
		output = self.fromCheckpoints(constructedSignalName, self.checkpoints[lowerBoundIndex: upperBoundIndex + 1])
		if interval.getLower() not in self.getTimes() and interval.getLower() > self.getTime(0):
			# If lower bound of the interval isn't included, and does fall within our defined range, compute it
			output.addCheckpoint(self.computeInterpolatedCheckpoint(interval.getLower()))
		if not half_open and interval.getUpper() not in self.getTimes() and interval.getUpper() < self.getTime(-1):
			# If upper bound of the interval isn't included, should be, and falls within our defined range, compute it
			output.addCheckpoint(self.computeInterpolatedCheckpoint(interval.getUpper()))
		return output

	def computeIndexForTime(self, time: float) -> int:
		""" Find the index where 'time' is located. Errors if time not in the current checkpoint list. """
		assert time in self.getTimes(), "Can't find an index for a time that isn't in our list."
		# Only the key element (time) matters for lookup
		return self.checkpoints.bisect_left(SignalValue(time, 0, 0))

	def computeLargestTimeBefore(self, time: float, inclusive: bool = True) -> float:
		""" Return the largest timestamp (specified in a checkpoint), smaller than (or equal to, if inclusive is True) the value in the parameter"""
		if inclusive:
			compare = lambda x, y: x <= y
		else:
			compare = lambda x, y: x < y
		# Iterate over all checkpoints, reverse order
		for i in reversed(range(len(self.checkpoints))):
			cp = self.checkpoints[i]
			if compare(cp.getTime(), time):
				# If checkpoint time <= currentTime, we have the largest time before currentTime
				# Because we are going through the cp times in descending order
				return cp.getTime()
		raise RuntimeError(f"Failed to find largestTimeBefore({time}) for {self}")

	def computeIndexForSmallestTimeAfter(self, time: float, inclusive: bool = True) -> int:
		""" Return the index at which the checkpoint with the timestamp closest to (but always larger than (or eq iff inclusive)) the given time is """
		smallestTimeAfter = self.computeSmallestTimeAfter(time, inclusive)
		return self.checkpoints.bisect_left(SignalValue(smallestTimeAfter, 0, 0))

	def computeIndexForLargestTimeBefore(self, time: float, inclusive: bool = True) -> int:
		""" Return the index at which the checkpoint with the timestamp closest to (but always smaller than (or eq iff inclusive)) the given time is """
		largestTimeBefore = self.computeLargestTimeBefore(time, inclusive)
		return self.checkpoints.bisect_left(SignalValue(largestTimeBefore, 0, 0))

	def computeSmallestTimeAfter(self, time: float, inclusive: bool = True) -> float:
		"""Get the smallest time (that is specified in a checkpoint) that is larger than (or equal to, if inclusive is True) the value in parameter"""
		if inclusive:
			compare = lambda x, y: x >= y
		else:
			compare = lambda x, y: x > y
		# This method assumes the times are sorted in ascending order
		for cp in self.checkpoints:
			if compare(cp.getTime(), time):
				# We're going through times in ascending order, so this is the smallest cptime after currentTime
				return cp.getTime()
		raise RuntimeError(f"Failed to find smallestTimeAfter({time}) for {self}")

	def oldFormat(self) -> List[List[float]]:
		"""Grab representation of this signal in the format used in old version of the code.\nMay be useful to compare outputs between the versions."""
		# Might be useful sometime. 
		return [self.getTimes(), self.getValues(), self.getDerivatives()]

	def computeLines(self) -> List[LineSegment]:
		ret: List[LineSegment] = []
		for i in range(self.getCheckpointCount() - 1):
			cpA: SignalValue = self.getCheckpoint(i)
			cpB: SignalValue = self.getCheckpoint(i+1)
			ret.append(LineSegment(Point(cpA.getTime(), cpA.getValue()), Point(cpB.getTime(), cpB.getValue())))
		return ret


	def getValues(self) -> List[float]:
		""" Get the values for the signal. """
		return [x.getValue() for x in self.checkpoints]

	def getTimes(self) -> List[float]:
		""" Get the times for the signal. """
		return [x.getTime() for x in self.checkpoints]

	def getDerivatives(self) -> List[float]:
		""" Get the derivatives for the signal. """
		return [x.getDerivative() for x in self.checkpoints]

	def getCheckpointCount(self) -> int:
		""" Get the size of the checkpoint list for the signal. """
		return len(self.checkpoints)

	def getCheckpoints(self) -> List[SignalValue]:
		""" Get the list of checkpoints for the signal. """
		return self.checkpoints

	def getName(self) -> str:
		""" Get the name for the signal. """
		return self.name

	def setName(self, name: str) -> None:
		""" Set the Signal's name attribute. """
		self.name = name

	def getLargestTime(self) -> float:
		""" Return the value of the largest timestamp """
		# Returns the checkpoint in self.checkpoints with c.getTime() largest
		return self.checkpoints[-1].getTime()

	def getTime(self, index: int) -> float:
		"""Return the timestamp of the signal checkpoint at the specified index"""
		return self.checkpoints[index].getTime()

	def getValue(self, index: int) -> float:
		"""Return the value of the signal checkpoint at the specified index"""
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		return self.checkpoints[index].getValue()

	def getDerivative(self, index: int) -> float:
		"""Return the derivative of the signal checkpoint at the specified index"""
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		return self.checkpoints[index].getDerivative()

	def getCheckpoint(self, index: int) -> SignalValue:
		"""Return the signal checkpoint at the specified index"""
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		return self.checkpoints[index]

	def setValue(self, index: int, value: float) -> None:
		""" Set the value for the checkpoint at index. """
		self.checkpoints[index].setValue(value)

	def setDerivative(self, index: int, derivative: float) -> None:
		""" Set the derivative for the checkpoint at index. """
		self.checkpoints[index].setDerivative(derivative)

	def getDefinedTimeInterval(self) -> Interval:
		""" Returns the Interval of time over which this Signal is defined -- starts at the first sample point, ends at the last. """
		# Checkpoints are sorted by time, so we can just get this by index.
		return Interval(self.getTime(0), self.getTime(-1))


	def popCheckpoint(self) -> SignalValue:
		"""Pop the last element from the chekcpoint list and return it"""
		return self.checkpoints.pop()

	def addCheckpoint(self, sv: SignalValue) -> None:
		"""Add a checkpoint to the signal. Insertion location is determined by the SignalValue's timestamp"""
		if sv.getTime() in self.getTimes():
			assert math.isclose(sv.getValue(), self.getValue(self.computeIndexForTime(sv.getTime())), rel_tol=1e-7), "Ensure that we attempt to add identical checkpoints only. These can be safely dropped, others can't."
			return
		if sv.getTime() != int(sv.getTime()):
			time = sv.getTime()
		# Use the emplace method to make a copy
		# If we simply .add(sv) we reference the same object. This may cause issues in e.g. the derivative computations.
		self.emplaceCheckpoint(sv.getTime(), sv.getValue(), sv.getDerivative())
		#self.checkpoints.add(sv.copy())

	# Similar to addCheckpoint, but creates the SignalValue internally
	def emplaceCheckpoint(self, time: float, value: float, derivative: float = None) -> None:
		"""Add a (constructed) checkpoint to the signal. Insertion location is determined by the timestamp"""
		# if derivative is None:
		# 	warnings.warn("Replaced None derivative with 0. Ensure this is correct behaviour.")
		if time in self.getTimes():
			assert math.isclose(value, self.getValue(self.computeIndexForTime(time)), rel_tol=1e-7), "Ensure that we attempt to add identical checkpoints only. These can be safely dropped, others can't."
			return
		self.checkpoints.add(SignalValue(time, value, derivative if derivative is not None else 0))

	def isEmpty(self) -> bool:
		""" Checks if the Signal is empty (i.e. contains no sample points)."""
		return self.getCheckpointCount() == 0

	def isSingular(self) -> bool:
		""" Returns if the signal is defined by a single sample point. """
		return self.getCheckpointCount() == 1

	def shift(self, offset: float) -> 'Signal': 
		"""Take the current timestamps, subtract offset"""
		cp: SignalValue
		newCheckpoints: List[SignalValue] = []
		for cp in self.checkpoints:
			newCheckpoints.append(SignalValue(cp.getTime() + offset, cp.getValue(), cp.getDerivative()))
		return self.fromCheckpoints(f"{self.name}_shift", newCheckpoints)

	def merge(self, other: 'Signal') -> None: 
		""" Takes all checkpoints from other and merges them into self.\n
		Requires that the timestamps are not equal for all checkpoints where the checkpoints are not identical. """
		assert all([cp.getTime() not in self.getTimes() or self.getCheckpoint(self.computeIndexForTime(cp.getTime())) == cp for cp in other.getTimes()])
		for cp in other.getCheckpoints():
			self.addCheckpoint(cp)


	def recomputeDerivatives(self):
		"""Re-compute the derivatives part of each SignalValue, to make sure it matches the current values."""
		if self.checkpoints: # no-op if empty list
			for i in range(len(self.checkpoints) - 1):
				valueDiff = self.checkpoints[i+1].getValue() - self.checkpoints[i].getValue()
				timeDiff = self.checkpoints[i+1].getTime() - self.checkpoints[i].getTime()
				if timeDiff == 0:
					assert False, "This shouldn't be possible - means we have a double time entry."
				self.checkpoints[i].setDerivative(valueDiff / timeDiff)
				if self.checkpoints[i+1].getValue() - self.checkpoints[i].getValue() != 0 and self.checkpoints[i].getDerivative() == 0:
					assert False, "wtf"
			self.checkpoints[-1].setDerivative(0)

	def __str__(self) -> str:
		ret = ["Signal with the following checkpoint entries: "]
		for cp in self.checkpoints:
			ret.append(f'\t{cp.getTime()} -> <{cp.getValue()}, {cp.getDerivative()}>')
		return '\n'.join(ret)

	def __repr__(self) -> str:
		times, values, derivatives = [],[],[]
		for x in self.checkpoints:
			times.append(x.getTime())
			values.append(x.getValue())
			derivatives.append(x.getDerivative())
		return f"Signal('{self.name}', {times.__repr__()}, {values.__repr__()}, {derivatives.__repr__()})"

	def __eq__(self, other: 'Signal') -> bool:
		if type(self) != type(other):
			return False
		if self.name != other.name:
			return False
		if len(self.checkpoints) != len(other.checkpoints):
			return False
		for scp, ocp in zip(self.checkpoints, other.checkpoints):
			if scp != ocp:
				return False
		return True