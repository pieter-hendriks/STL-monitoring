from .signalvalue import SignalValue
import pandas as pd
from typing import List
import warnings
import numpy
from sortedcontainers import SortedList
from ..utility import binarySearch

# TODO: Maybe replace checkpoints with list of times + dict[Time -> Value, Derivative]
class Signal:
	# A class for managing SignalValues
	# A signal is specified as a list of time/value pairs (with optional derivative)
	# The getValue function returns the value specified, at the largest timestamp <= the requested time
	def __init__(self, name: str = None, times: List[float] = None, values: List[float] = None, derivatives: List[float] = None):
		if name is not None and type(name) != str:
			raise RuntimeError(f"Name argument is {type(name)} (value = {name}) instead of str")
		if all([name is None, times is None, values is None, derivatives is None]):
			self.name = "Autogenerated"
			self.checkpoints: SortedList[SignalValue] = SortedList([], key = lambda x: x.getTime())
		else:
			if times is not None:
				assert values is not None, "We can't autocompute values."
				assert all([times[i] != times[i+1] for i in range(len(times) - 1)]), "debug assert: times mustn't be equal"
			elif values is not None:
				assert False, "DEBUG STATEMENT: May need to autogenerate timestamps here."
			self.name: str = name
			if derivatives is None and times is not None:
				warnings.warn("Signal is autocomputing derivatives!")
				derivatives = [(values[i] + values[i+1]) / (times[i+1] - times[i]) for i in range(len(times) - 1)] + [0]
			if times is None:
				times = []
			if values is None:
				values = []
			if derivatives is None:
				derivatives = []
			self.checkpoints: List[SignalValue] = SortedList([SignalValue(x, y, d) for x, y, d in zip(times, values, derivatives)], key = lambda x: x.getTime())
	
	def getValues(self) -> List[float]:
		return [x.getValue() for x in self.checkpoints]

	def getTimes(self) -> List[float]:
		return [x.getTime() for x in self.checkpoints]

	def getDerivatives(self) -> List[float]:
		return [x.getDerivative() for x in self.checkpoints]
	
	def getCheckpointCount(self) -> int:
		return len(self.checkpoints)

	def getName(self) -> str:
		return self.name

	def getIndexForTime(self, t: float) -> int:
		return binarySearch(t, self.checkpoints, lambda x: x.getTime())[0]
		
	def getSubset(self, x: float, y: float, halfopen: bool = False) -> List[SignalValue]:
		assert x in self.getTimes() and y in self.getTimes()
		xIndex, _ = binarySearch(x, self.checkpoints, lambda x: x.getTime())
		yIndex, _ = binarySearch(y, self.checkpoints, lambda x: x.getTime())
		if halfopen:
			return self.checkpoints[xIndex:yIndex]
		return self.checkpoints[xIndex:yIndex + 1]

	def computeDerivatives(self, times: List[float], values: List[float]) -> List[float]:
		dydx = numpy.diff(times) / numpy.diff(values)
		return list(dydx) + [0]

	def verifyPreConditions(self, times: List[float], values: List[float], derivatives: List[float] = None) -> None:
		assert len(times) == len(values), "Signal must have one value per timestamp"
		assert derivatives is None or len(derivatives) == len(times), "Derivatives must be either None or must have exactly one per timestep."
		assert all([x >= 0 for x in times]), "Times must be >= 0"

	def getLargestTime(self) -> float:
		# Returns the checkpoint in self.checkpoints with c.getTime() largest
		return self.checkpoints[-1].getTime()

	def getLargestTimeBefore(self, currentTime: float, inclusive: bool = True) -> float:
		if inclusive:
			compare = lambda x, y: x <= y
		else:
			compare = lambda x, y: x < y
		# This method assumes the times are sorted in ascending order
		# Time must not be negative
		assert currentTime >= 0
		# Iterate over all checkpoints, reverse order
		for cp in reversed(self.checkpoints):
			# Keep going as long as parameter time < checkpoint time
			if compare(cp.getTime(), currentTime):
				# If checkpoint time <= currentTime, we have the largest time before currentTime
				# Because we are going through the cp times in descending order
				return cp.getTime()
		raise RuntimeError(f"Failed to find largestTimeBefore({currentTime}) for {self}")
	
	def getSmallestTimeAfter(self, currentTime: float, inclusive: bool = True) -> float:
		if inclusive:
			compare = lambda x, y: x >= y
		else:
			compare = lambda x, y: x > y
		# This method assumes the times are sorted in ascending order
		# Time must not be negative
		assert currentTime >= 0
		for cp in self.checkpoints:
			if compare(cp.getTime(), currentTime):
				# We're going through times in ascending order, so this is the smallest cptime after currentTime
				return cp.getTime()
		raise RuntimeError(f"Failed to find smallestTimeBefore({currentTime}) for {self}")

	def getTime(self, index: int) -> float:
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		try:
			return self.checkpoints[index].getTime()
		except IndexError:
			print(self.checkpoints)
			print(len(self.checkpoints))
			print(index)
			print("^^^FUCK^^^")
			raise

	def getValue(self, index: int) -> float:
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		return self.checkpoints[index].getValue()

	def getDerivative(self, index: int) -> float:
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		return self.checkpoints[index].getDerivative()

	def getCheckpoint(self, index: int) -> SignalValue:
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		return self.checkpoints[index]

	def computeAbsoluteValue(self) -> None:
		# Compute the absolute value for all values
		# This is a no-op for BooleanSignals, does work for non-Boolean Signals.
		for i in range(len(self.checkpoints)):
			self.checkpoints[i].setValue(abs(self.checkpoints[i].getValue()))
		self.recomputeDerivatives()

	def recomputeDerivatives(self):
		if self.checkpoints: # no-op if empty list
			for i in range(len(self.checkpoints) - 1):
				valueDiff = self.checkpoints[i+1].getValue() - self.checkpoints[i].getValue()
				timeDiff = self.checkpoints[i+1].getTime() - self.checkpoints[i].getTime()
				self.checkpoints[i].setDerivative(valueDiff / timeDiff)
			self.checkpoints[-1].setDerivative(0)

	def __str__(self) -> str:
		ret = ["Signal with the following checkpoint entries: "]
		for cp in self.checkpoints:
			ret.append(f'\t{cp.getTime()} -> <{cp.getValue()}, {cp.getDerivative()}>')
		return '\n'.join(ret)

	def __repr__(self) -> str:
		times, values, derivatives = [],[],[]
		for x in self.checkpoints:
			times.append(x.getTime())
			values.append(x.getValue())
			derivatives.append(x.getDerivative())
		return f"Signal('{self.name}', {times.__repr__()}, {values.__repr__()}, {derivatives.__repr__()})"

	def addCheckpoint(self, sv: SignalValue) -> None:
		self.checkpoints.add(sv)

	# Similar to addCheckpoint, but creates the SignalValue internally
	def emplaceCheckpoint(self, time: float, value: float, derivative: float = None) -> None:
		if derivative is None:
			warnings.warn("Replaced None derivative with 0. Ensure this is correct behaviour.")
		self.checkpoints.add(SignalValue(time, value, derivative if derivative is not None else 0))

	def popCheckpoint(self) -> None:
		self.checkpoints.pop()

	# Get the value of a signal at time step t
	def getAffinePoint(signal, t):
		if t > max(signal[0]):  # If affine point outside of the given signal
			return signal[1][-1] + signal[2][-1] * (t - signal[0][-1])  # Calculate using derivative (fplc)
		# Search the location of the time step t in the signal
		i = 0
		while signal[0][i] <= t:
			# If a value already exists on t
			if signal[0][i] == t:
				return signal[1][i]
			i += 1
		# If the time step t is before the singal started
		if i == 0:
			return signal[1][i]
		# If the time step t is after the signal
		elif i >= len(signal[0]):
			return signal[1][-1]
		# If the time step t is somewhere in the signal but no value exists yet, calculate knowing it's fplc
		else:
			return float(signal[1][i] - signal[1][i - 1]) / float(signal[0][i] -
																														signal[0][i - 1]) * float(t - signal[0][i - 1]) + signal[1][i - 1]


	def __eq__(self, other: 'Signal') -> bool:
		if self.name != other.name:
			return False
		if len(self.checkpoints) != len(other.checkpoints):
			return False
		for scp, ocp in zip(self.checkpoints, other.checkpoints):
			if scp != ocp:
				return False
		return True


def booleanize(value: float):
	return 1 if value > 0 else 0

# TODO: Verify if there are any other behavioural differences.
# For example, in quantitative, we might interpolate the value of signal between
# checkpoints, this is undesirable for the boolean case, most likely.
class BooleanSignal(Signal):
	# BooleanSignal is a special case of a signal, with an additional requirement on the values (only 1 (T) or 0 (F) allowed)
	# There's a few algorithmic differences as well; these will be handled in the algorithm functions.
	def __init__(self, name: str = None, times: List[float] = None, values: List[float] = None, derivatives: List[float] = None) -> None:
		if values and not all([x == 1 or x == 0 for x in values]):
			newValues = [booleanize(x) for x in values]
			warnings.warn(f"Booleanized a non-Boolean value list in the BooleanSignal class:\n\t{values}\n\t==>\n\t{newValues}\nValue <= 0 is considered False in this conversion.")
			values = newValues
		assert derivatives is None or all([x == 0 for x in derivatives]), f"Boolean signal initialized with non-zero derivative values: {derivatives}"
		# In case of empty signal, fill empty lists + dummy name
		if name is None:
			name = "autogeneratedBoolean"
			assert times is None and values is None and derivatives is None
			times, values, derivatives = [], [], []
		if values is None:
			values = []
		else:
			assert times is not None, "DEBUG ASSERT: have to autogenerate timestamps"
		if times is None:
			times = []
		else:
			assert values is not None, "We can't autogenerate values for times."
		if derivatives is None:
				# Set derivative to all zeroes, since it's not meaningful for a Boolean signal
				derivatives = [0] * len(times)
		# We don't necessarily fill in all None-valued arguments. The super class (Signal) will take care of this for us.
		super().__init__(name, times, values, derivatives)
	
	def emplaceCheckpoint(self, time: float, value: float, derivative: float = None) -> None:
		# Booleanize the value
		if value not in [1, 0]:
			value = booleanize(value)
		# Add the checkpoint to the list. Derivative should be zero always, I think, for BooleanSignal.
		# For now, we still allow non-zero if explicitly given, since we haven't verified that.
		# TODO: Determine if non-zero derivative for BooleanSignal can ever happen
		self.checkpoints.add(SignalValue(time, value, derivative if derivative is not None else 0))
	
	def recomputeDerivatives(self):
		for cp in self.checkpoints:
			cp.setDerivative(0)

	@classmethod
	def fromSignal(cls, s: Signal):
		# Get the components of the original Signal
		times, values, derivatives = zip(*[(cp.getTime(), cp.getValue(), cp.getDerivative()) for cp in s.checkpoints])
		# Drop the derivatives, BooleanSignal doesn't use those.
		return cls(s.getName(), times, values, [0] * len(derivatives))

	



class SignalList(List[Signal]):
	# A class for managing a list of Signals.

	# Init is handled by List, so just pass-through
	def __init__(self, *args, **kwargs) -> None:
		super().__init__(*args, **kwargs)

	# TODO: Optimisation? Is switching to sorted list worth? For now, no performance issues.
	def getByName(self, name: str) -> Signal:
		signal: Signal
		for signal in self:
			if signal.getName() == name:
				return signal
		raise RuntimeError(F"Signal with name '{name}' not found.")
		
	@classmethod
	def fromCSV(cls, csv: str) -> 'SignalList':
		# Read Signals from CSV, return a SignalList instance
		# Column names in CSV should be 's', 's_t' and 's_d' for signal s (s must not contain '_')
		data = pd.read_csv(csv)
		colTitles = data.columns.values
		# Ensure columns are named correctly
		_verifyTitleNaming(colTitles)
		# Get the data from the dataframe
		signals, timestamps, derivatives = _findSignalColumns(colTitles), _findTimestampColumns(colTitles), _findDerivativeColumns(colTitles)
		_verifyColumns(signals, timestamps, derivatives, colTitles)
		# If we only have Boolean values, use the BooleanSignal class to initialize
		signalDataType = BooleanSignal if _isAllBooleanSignals(signals) else Signal
		ret = []
		for signal in signals:
			# Pattern as expected (and verified), read from dataframe into list of Signals
			timestamp = signal + '_t'
			derivative = signal + '_d'
			# Add Signal to the list
			if len(derivatives) != 0:
				ret.append(signalDataType(signal, list(data.loc[:,timestamp]), list(data.loc[:, signal]), list(data.loc[:,derivative])))
			else:
				ret.append(signalDataType(signal, list(data.loc[:,timestamp]), list(data.loc[:,signal])))
		return SignalList(ret)



# Helper functions for input handling


def _isAllBooleanSignals(signals: List[List[float]]) -> bool:
	return all([all([x == 1 or x == 0 for x in signal]) for signal in signals])


def _findSignalColumns(colTitles: List[str]) -> List[str]:
	return _findAllMatchingPattern(colTitles, '_', invertCondition = True)

# Timestamps must be labeled 'x_t' for any signal x
def _findTimestampColumns(colTitles: List[str]) -> List[str]:
	return _findAllMatchingPattern(colTitles, '_t')
	
# Derivatives must be labeled 'x_d' for any signal x
def _findDerivativeColumns(colTitles: List[str]) -> List[str]:
	return _findAllMatchingPattern(colTitles, '_d')
	
def _findAllMatchingPattern(collection: List[str], pattern: str, invertCondition: bool = False) -> List[str]:
	if invertCondition:
		return [c for c in collection if pattern not in c]
	return [c for c in collection if pattern in c]
	
def _verifyTitleNaming(titles: List[str]) -> None:
	# Underscores may only be followed by 'd' and 't', and that must be the end of the string.
	for title in titles:
		try:
			underscore = title.rindex('_')
		except ValueError:
		# Titles with no underscores present are allowed
			continue
		assert title[underscore + 1] in ['d', 't'], "Underscore must be followed by either 'd' or 't'. No other character is allowed."
		assert underscore + 1 == len(title) - 1, "The '_d' or '_t' pattern present in signal name must be the last part of the signal name."

def _verifyColumns(signals: List[str], timestamps: List[str], derivatives: List[str], colTitles: List[str]) -> None:
	# Verify all data is extracted
	assert len(signals) + len(timestamps) + len(derivatives) == len(colTitles), "Extracted column count does not match csv column count."
	# Verify we have the same amount of data points for each.
	assert len(timestamps) == len(signals), "Signal value and timestamp lists must have the same length."
	# Ensure all timestamps are found in the signals
	assert all([timestamp[:-2] in signals for timestamp in timestamps]), "Timestamp names, without '_t' must all be found in signal names."
	assert all([signal + '_t' in timestamps for signal in signals]), "Signal names, with '_t' suffix must all be found in timestamp names."
	# Ensure all derivatives 
	if len(derivatives) != 0:
		assert all([derivative[:-2] in signals for derivative in derivatives]), "Derivative names, without '_d' must all be found in signal names."
		assert all([signal + '_d' in derivatives for signal in signals]), "Signal names, with '_d' suffix must all be found in derivative names."
		assert len(derivatives) == len(signals), "If any derivatives are present, all derivatives must be present."
