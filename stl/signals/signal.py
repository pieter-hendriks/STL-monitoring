from .signalvalue import SignalValue
import pandas as pd
from typing import List, Tuple
import warnings
import numpy
from sortedcontainers import SortedList
from ..utility import binarySearch
from ..utility import Interval


# TODO: Maybe replace checkpoints with list of times + dict[Time -> Value, Derivative]
class Signal:
	# A class for managing SignalValues
	# A signal is specified as a list of time/value pairs (with optional derivative)
	# The getValue function returns the value specified, at the largest timestamp <= the requested time
	def __init__(self, name: str = None, times: List[float] = None, values: List[float] = None, derivatives: List[float] = None):
		if name is not None and type(name) != str:
			raise RuntimeError(f"Name argument is {type(name)} (value = {name}) instead of str")
		if all([name is None, times is None, values is None, derivatives is None]):
			self.name = "Autogenerated"
			self.checkpoints: SortedList[SignalValue] = SortedList([], key = lambda x: x.getTime())
		else:
			if times is not None:
				assert values is not None, "We can't autocompute values."
				assert all([times[i] != times[i+1] for i in range(len(times) - 1)]), "debug assert: times mustn't be equal"
			elif values is not None:
				assert False, "DEBUG STATEMENT: May need to autogenerate timestamps here."
			self.name: str = name
			if derivatives is None and times is not None:
				warnings.warn("Signal is autocomputing derivatives!")
				derivatives = [(values[i] + values[i+1]) / (times[i+1] - times[i]) for i in range(len(times) - 1)] + [0]
			if times is None:
				times = []
			if values is None:
				values = []
			if derivatives is None:
				derivatives = []
			self.checkpoints: SortedList[SignalValue] = SortedList([SignalValue(x, y, d) for x, y, d in zip(times, values, derivatives)], key = lambda x: x.getTime())
	
	@classmethod
	def fromBooleanSignal(cls, s: 'BooleanSignal'): # type: ignore  (Necessary because pylance doesn't support this annotation)
		if not s.checkpoints:
			return cls(s.getName())
		times, values, derivatives = zip(*[(cp.getTime(), cp.getValue(), cp.getDerivative()) for cp in s.checkpoints])
		# Drop the derivatives, BooleanSignal doesn't use those.
		newSignal = cls(s.getName(), times, values, derivatives)
		newSignal.recomputeDerivatives()
		return newSignal

	def getInterval(self, interval: Interval, half_open: bool = False) -> 'Signal':
		# Get an interval of a signal between time steps a and b
		# If half open, the last value of time step b will not be included
		constructedSignalName = f"{self.getName()}_interval"
		if interval.getLower() > self.getTime(-1):
			return Signal(constructedSignalName, [interval.getLower(), interval.getUpper()+1], [self.getValue(-1)]*2, [0, 0])
		warnings.warn("Dropped upper() < time check")
		# elif interval.getUpper() < self.getTime(0):
		# 	return Signal(constructedSignalName, [interval.getLower(), interval.getUpper()+1], [self.getValue(0)]*2, [0, 0])
		# Find the first value of the signal that is in the interval
		x = self.getSmallestTimeAfter(interval.getLower())
		# If the interval is [a, a]
		if interval.getLower() == interval.getUpper():
			if half_open:
				# In case of half open, that's an empty interval
				warnings.warn("Returning empty signal in getSignalInterval")
				return Signal(constructedSignalName)
			else:
				# If closed, we should get one value at time interval.getLower()
				warnings.warn("Dropped some derivative code here, verify that the functionality is correct.")
				#TODO: Ensure above warning doesn't apply. Derivative is currently [0] everywhere on last element.
				# Not sure what computation in original implementation was for (see below.)
				
				# if signal[0].index(x) == 0:
				# 	derivative = 0
				# else:
				# 	derivative = signal[2][signal[0].index(x) - 1]
				return Signal(constructedSignalName, [interval.getLower()], [self.getAffinePoint(interval.getLower())], [0])
		# Search the last value of the signal that is in the interval
		# Inclusive if the interval is closed
		y = self.getLargestTimeBefore(interval.getUpper(), not half_open) 
		# Now, [x, y] is the interval in signal checkpoints, with x >= a and y <= b.
		result = Signal(constructedSignalName)
		# Do this separately since Signal only allows construction in ascending order of time
		if x > interval.getLower():
			# We dropped part of the interval here, because we don't have an exact checkpoint. Compute best estimate.
			result.emplaceCheckpoint(interval.getLower(), self.getAffinePoint(interval.getLower()), numpy.diff([self.getValue(0), self.getValue(1)]) / numpy.diff([self.getTime(0), self.getTime(1)]))
		# if x == interval.getLower(), it'll be included in getSubset so we don't have to worry about else clause

		# Our computation of y already includes the half-open property, so here we can just always have a half-open interval
		for signalvalue in self.getSubset(x, y, False): 
			result.addCheckpoint(signalvalue)
		# if y == interval.getUpper() (and it should be included), it'll be included by the subset.
		# half_open in this case doesn't really do much - it only makes it so the last checkpoint of signal isn't considered if it's exactly equal. 
		# TODO: Is half_open not applying when timestamp not in signal intentional?
		if y < interval.getUpper():
			result.emplaceCheckpoint(interval.getUpper(), self.getAffinePoint(interval.getUpper()), numpy.diff([self.getValue(-2), self.getValue(-1)] / numpy.diff([self.getTime(-2), self.getTime(-1)])))

		return result

	def getValues(self) -> List[float]:
		return [x.getValue() for x in self.checkpoints]

	def getTimes(self) -> List[float]:
		return [x.getTime() for x in self.checkpoints]

	def getDerivatives(self) -> List[float]:
		return [x.getDerivative() for x in self.checkpoints]
	
	def getCheckpointCount(self) -> int:
		return len(self.checkpoints)

	def getName(self) -> str:
		return self.name

	def getIndexForTime(self, t: float) -> int:
		assert t in self.getTimes()
		# Only the key element (time) matters for lookup
		return self.checkpoints.bisect_left(SignalValue(t, 0, 0))
		# return binarySearch(t, self.checkpoints, lambda x: x.getTime())[0]
		
	def getSubset(self, x: float, y: float, halfopen: bool = False) -> List[SignalValue]:
		assert x in self.getTimes() and y in self.getTimes()
		# SortedList uses the .getTime() function to grab the key
		# re-using SignalValue class is easiest way to avoid erroring
		xIndex = self.checkpoints.bisect_left(SignalValue(x, 0, 0))
		yIndex = self.checkpoints.bisect_left(SignalValue(y, 0, 0))
		if halfopen:
			# print(f"Subset[{x}, {y}, halfopen={halfopen}] of {self.oldFormat()} =\n\t{self.checkpoints[xIndex:yIndex]} (Indices: [{xIndex}, {yIndex}])")
			return self.checkpoints[xIndex:yIndex]
		# print(f"Subset[{x}, {y}, halfopen={halfopen}] of {self.oldFormat()} =\n\t{self.checkpoints[xIndex:yIndex+1]} (Indices: [{xIndex}, {yIndex+1}])")
		return self.checkpoints[xIndex:yIndex + 1]

	def computeDerivatives(self, times: List[float], values: List[float]) -> List[float]:
		dydx = numpy.diff(times) / numpy.diff(values)
		return list(dydx) + [0]

	def verifyPreConditions(self, times: List[float], values: List[float], derivatives: List[float] = None) -> None:
		assert len(times) == len(values), "Signal must have one value per timestamp"
		assert derivatives is None or len(derivatives) == len(times), "Derivatives must be either None or must have exactly one per timestep."
		assert all([x >= 0 for x in times]), "Times must be >= 0"

	def getLargestTime(self) -> float:
		# Returns the checkpoint in self.checkpoints with c.getTime() largest
		return self.checkpoints[-1].getTime()

	def getLargestTimeBefore(self, time: float, inclusive: bool = True) -> float:
		if inclusive:
			compare = lambda x, y: x <= y
		else:
			compare = lambda x, y: x < y
		# Time must not be negative
		assert time >= 0
		# Iterate over all checkpoints, reverse order
		for i in reversed(range(len(self.checkpoints))):
			cp = self.checkpoints[i]
			if compare(cp.getTime(), time):
				# If checkpoint time <= currentTime, we have the largest time before currentTime
				# Because we are going through the cp times in descending order
				return cp.getTime()
		raise RuntimeError(f"Failed to find largestTimeBefore({time}) for {self}")
	
	def getSmallestTimeAfter(self, time: float, inclusive: bool = True) -> float:
		print("Getting smallestTimeAfter:", time)
		if time == 2:
			pass
		if inclusive:
			compare = lambda x, y: x >= y
		else:
			compare = lambda x, y: x > y
		# This method assumes the times are sorted in ascending order
		# Time must not be negative
		assert time >= 0
		for cp in self.checkpoints:
			if compare(cp.getTime(), time):
				# We're going through times in ascending order, so this is the smallest cptime after currentTime
				print(f"\tValue = {cp.getTime()}")
				return cp.getTime()
		raise RuntimeError(f"Failed to find smallestTimeAfter({time}) for {self}")

	def getTime(self, index: int) -> float:
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		try:
			return self.checkpoints[index].getTime()
		except IndexError:
			print(self.checkpoints)
			print(len(self.checkpoints))
			print(index)
			print("^^^FUCK^^^")
			raise

	def getValue(self, index: int) -> float:
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		return self.checkpoints[index].getValue()

	def getDerivative(self, index: int) -> float:
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		return self.checkpoints[index].getDerivative()

	def getCheckpoint(self, index: int) -> SignalValue:
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		return self.checkpoints[index]

	def computeAbsoluteValue(self) -> None:
		# Compute the absolute value for all values
		# This is a no-op for BooleanSignals, does work for non-Boolean Signals.
		for i in range(len(self.checkpoints)):
			self.checkpoints[i].setValue(abs(self.checkpoints[i].getValue()))
		self.recomputeDerivatives()

	def recomputeDerivatives(self):
		if self.checkpoints: # no-op if empty list
			for i in range(len(self.checkpoints) - 1):
				valueDiff = self.checkpoints[i+1].getValue() - self.checkpoints[i].getValue()
				timeDiff = self.checkpoints[i+1].getTime() - self.checkpoints[i].getTime()
				self.checkpoints[i].setDerivative(valueDiff / timeDiff)
			self.checkpoints[-1].setDerivative(0)

	def __str__(self) -> str:
		ret = ["Signal with the following checkpoint entries: "]
		for cp in self.checkpoints:
			ret.append(f'\t{cp.getTime()} -> <{cp.getValue()}, {cp.getDerivative()}>')
		return '\n'.join(ret)

	def __repr__(self) -> str:
		times, values, derivatives = [],[],[]
		for x in self.checkpoints:
			times.append(x.getTime())
			values.append(x.getValue())
			derivatives.append(x.getDerivative())
		return f"Signal('{self.name}', {times.__repr__()}, {values.__repr__()}, {derivatives.__repr__()})"

	def addCheckpoint(self, sv: SignalValue) -> None:
		self.checkpoints.add(sv)

	# Similar to addCheckpoint, but creates the SignalValue internally
	def emplaceCheckpoint(self, time: float, value: float, derivative: float = None) -> None:
		# if derivative is None:
		# 	warnings.warn("Replaced None derivative with 0. Ensure this is correct behaviour.")
		self.checkpoints.add(SignalValue(time, value, derivative if derivative is not None else 0))

	def oldFormat(self) -> List[List[float]]:
		# Might be useful sometime. 
		return [self.getTimes(), self.getValues(), self.getDerivatives()]

	def popCheckpoint(self) -> SignalValue:
		return self.checkpoints.pop()

	def intersectAtIndex(self, other: 'Signal', index: int) -> Tuple[float, float]:
		assert index > 0 and len(self.checkpoints) > index, "Requested index is out of range for the current signal."
		assert len(other.checkpoints) > index, "Requested index out of range for the other signal."
		xdiff = self.getTime(index-1) - self.getTime(index), other.getTime(index-1) - other.getTime(index)
		ydiff = self.getValue(index-1) - self.getValue(index), other.getValue(index-1) - other.getValue(index)

		def det(a: Tuple[float, float], b: Tuple[float, float]):
			return a[0] * b[1] - a[1] * b[0]

		div = det(xdiff, ydiff)
		if div == 0:
			raise Exception('lines do not intersect')
		d = [det((x.getTime(index-1), x.getValue(index-1)), (x.getTime(index), x.getValue(index))) for x in [self, other]]
		x = det(d, xdiff) / div
		y = det(d, ydiff) / div
		return x, y

	# Get the value of a signal at time step t
	def getAffinePoint(self, t: float) -> float:
		if t > self.getLargestTime():
			# Compute using derivative if it falls outside of known values
			return self.getValue(-1) + self.getDerivative(-1) * (t - self.getTime(-1))
		i = 0
		# If it's within known values, find the correct time step
		while self.getTime(i) < t:
			i += 1
		if i == 0 or self.getTime(i) == t:
			# If point before signal started, return first data point
			# If it's an exact data point in the signal, return corresponding value
			return self.getValue(i)
		elif i >= self.getCheckpointCount():
			# If it's after the end of signal, return last data point
			return self.getValue(-1)
		else:
			# If it's somewhere between two data points, interpolate
			value = self.getValue(i - 1)
			value += (self.getValue(i) - self.getValue(i-1)) / ((self.getTime(i) - self.getTime(i-1)) * t - self.getTime(i-1))
			return value	# Get the value of a signal at time step t

	# Get a derivative of the signal at time step t
	def getAffineDerivative(self, t: float):
		if t < self.getTime(0):
			return 0
		for i in range(self.getCheckpointCount()):
			if t < self.getTime(i):
				# Signal is linearly interpolated between points, so derivative is constant on the interval [i-1, i)
				return self.getDerivative(i-1)


	def __eq__(self, other: 'Signal') -> bool:
		if type(self) != type(other):
			return False
		if self.name != other.name:
			return False
		if len(self.checkpoints) != len(other.checkpoints):
			return False
		for scp, ocp in zip(self.checkpoints, other.checkpoints):
			if scp != ocp:
				return False
		return True