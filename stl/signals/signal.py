""" Implementation of a list of signals; contains some QoL methods for reading from files """
from typing import List, Tuple, Iterable
import warnings
import math
from sortedcontainers import SortedList
from .signalvalue import SignalValue
from ..utility import Interval, LineSegment, Point


def sortedListKeyFunction(x: SignalValue):
	""" Helper method to act as a key in sorted list.
	Not a lambda because lambdas don't pickle."""
	return x.getTime()


# pylint: disable=too-many-public-methods
class Signal:
	""" Implementation of the Signal class for STL
	Contains a set of timeseries data values with associated timestamp and derivative.
	Between two such data points, Signals are assumed to be continuous. """

	def __init__(
	    self, name: str = None, times: List[float] = None, values: List[float] = None, derivatives: List[float] = None
	):
		""" Initializes a Signal. Name is autogenerated if not given.
		Set of times must be sorted in ascending order and must not contain duplicates. """
		# Ensure that name is valid (a string or None)
		if name is not None and not isinstance(name, str):
			raise RuntimeError(f"Name argument is {type(name)} (value = {name}) instead of str")
		if name is None:
			name: str = "defaultname"
		self.name: str = name

		# Check that all times are unequal -- if times is not given in ascending order, bugs may appear.
		if times is not None:
			assert values is not None, "We can't autocompute values."
			assert all(times[i] != times[i + 1] for i in range(len(times) - 1)), "debug assert: times mustn't be equal"
			if len(times) != len(values):
				assert len(times) == len(values)
		elif values is not None:
			# This shouldn't be reached in our usual cases - autogenerating timestamps seems weird.
			assert False, "DEBUG STATEMENT: May need to autogenerate timestamps here."
		# Set the variables to avoid errors in initialization

		# If no values, the result should be empty signal
		safeValue = values if values is not None else []
		# Times are autogenerated to index of value if none given
		safeTime = [round(x, 5) for x in times] if times is not None else list(range(len(safeValue)))
		# Derivatives are zero if none given
		safeDeriv = derivatives if derivatives is not None else [0] * len(safeValue)
		# Prevent errors
		assert len(safeValue) == len(safeTime) == len(safeDeriv)
		# Initialize
		# For efficient item access, we need the sorted list to not be a tree
		# This allows O(1) index access instead of O(log n) index access.
		self.checkpoints: Iterable[SignalValue] = SortedList(key=sortedListKeyFunction)
		self.checkpoints._load = 2**62 - 1
		self.times: Iterable[float] = SortedList()
		self.times._load = 2**62 - 1
		# Fill the lists after setting them to be 1-level max
		if safeTime:
			self.checkpoints.update(SignalValue(x, y, d) for x, y, d in zip(safeTime, safeValue, safeDeriv))
			self.times.update(safeTime)

		if derivatives is None:
			self.recomputeDerivatives()

	@classmethod
	def createConstant(cls, name: str, value: float, timestamps: List[float] = (0, float('inf'))) -> 'Signal':
		""" Create a constant Signal. Timestamps = [0, float('inf')] if unspecified. """
		s = cls(name)
		s.checkpoints.update(SignalValue(time, value, 0) for time in timestamps)
		s.times.update(x for x in timestamps)
		return s

	# We type-hint s as 'Signal' to avoid circular import
	# It should be BooleanSignal, in principle. But in effect, this method would work equally well from another Signal.
	@classmethod
	def fromBooleanSignal(cls, s: 'Signal') -> 'Signal':
		""" Conversion from a Boolean Signal. """
		if not s.checkpoints:
			return cls(s.getName())
		times, values, derivatives = zip(*[(cp.getTime(), cp.getValue(), cp.getDerivative()) for cp in s.checkpoints])
		newSignal = cls(s.getName(), times, values, derivatives)
		# Since we convert from Boolean, compute the derivatives.
		newSignal.recomputeDerivatives()
		return newSignal

	@classmethod
	def fromCheckpoints(cls, name: str, checkpoints: List[SignalValue]) -> 'Signal':
		""" Constructs a Signal instance from a list of checkpoints. Useful for copying. """
		s = cls(name)
		s.checkpoints.update(checkpoints)
		s.times.update(x.getTime() for x in checkpoints)
		return s

	@classmethod
	def computeCheckpointsForComparableSignal(cls, lhsSignal: 'Signal', rhsSignal: 'Signal') -> Tuple['Signal', 'Signal']:
		""" Gets the checkpoints (sample points) with timestamps from either Signal
		(computing interpolated value for the other Signal when necessary)
		where the timestamps fall within the Interval in which both signals are defined (i.e. intersect(lhsInterval,)). """
		# These may be Signal or BooleanSignal; annotated Signal because BooleanSignal is a subclass
		lhsResult: Signal = cls("lhs")
		rhsResult: Signal = cls('rhs')
		cp: SignalValue
		if not lhsSignal.getTimes() or not rhsSignal.getTimes():
			# If either signal is empty, the intersection is empty
			return lhsResult, rhsResult
		bothDefinedInterval: Interval = Interval.computeIntersection(
		    lhsSignal.getDefinedTimeInterval(), rhsSignal.getDefinedTimeInterval()
		)
		for cp in lhsSignal.getCheckpoints():
			if bothDefinedInterval.contains(cp.getTime()):
				lhsResult.addCheckpoint(cp)
				rhsResult.emplaceCheckpoint(
				    cp.getTime(), rhsSignal.computeInterpolatedValue(cp.getTime()),
				    rhsSignal.computeInterpolatedDerivative(cp.getTime())
				)
		for cp in rhsSignal.getCheckpoints():
			# Avoid double entries by checking if the given time is already in the result.
			if bothDefinedInterval.contains(cp.getTime()) and cp.getTime() not in rhsResult.getTimes():
				rhsResult.addCheckpoint(cp)
				lhsResult.emplaceCheckpoint(
				    cp.getTime(), lhsSignal.computeInterpolatedValue(cp.getTime()),
				    lhsSignal.computeInterpolatedDerivative(cp.getTime())
				)
		return lhsResult, rhsResult

	@classmethod
	def computeComparableSignals(cls, lhsSignal: 'Signal', rhsSignal: 'Signal') -> 'SignalList':  # type: ignore
		""" Create Signals that are comparable - this requires both Signals having the same sample point timings.\n
		First, we take all sample points from either Signal within the Interval in which both are defined.\n
		Second, we compute all points where, based on the derivative, the Signals intersect. \n
		Returns two Signals with an equal amount of sample points, where the time part of each sample point pair is equal."""

		# Get the sampling points where self and other are a) both defined or b) intersect
		# So, any time x where x in self.times() and x in other.times()
		# + any time y where, through the derivatives, we know that self.value(x) == other.value(x), assuming interpolation.
		assert isinstance(lhsSignal, type(rhsSignal)), "Operation is unsupported between signals of different semantics."
		lhsResult: Signal = cls('empty')
		rhsResult: Signal = cls('empty')
		if lhsSignal.isEmpty() or rhsSignal.isEmpty():
			return [lhsResult, rhsResult]
		# We build the sequence (ri)iâ‰¤nz containing the sampling points of y and y' when they are both defined,
		#  and the points where y and y' punctually intersect
		# First, we get the sampling points from the signals where they are both defined
		# (i.e. any t in s1 or s2 s.t. it is in domain of both)
		lhsResult, rhsResult = cls.computeCheckpointsForComparableSignal(lhsSignal, rhsSignal)
		# Second, we get the intersection points
		if not lhsResult.isEmpty() and not rhsResult.isEmpty():
			lhsLines: List[LineSegment] = lhsResult.computeLines()
			rhsLines: List[LineSegment] = rhsResult.computeLines()
			intersectPoints: List[Point] = LineSegment.computeIntersectionPoints(lhsLines, rhsLines)
			for point in intersectPoints:
				point.normalize()
				lhsResult.emplaceCheckpoint(point.x, point.y, 0)
				rhsResult.emplaceCheckpoint(point.x, point.y, 0)
		lhsResult.recomputeDerivatives()
		rhsResult.recomputeDerivatives()
		assert lhsResult.getTimes() == rhsResult.getTimes(
		), "The punctual intersection function must return two Signals with exactly equal time checkpoints."
		return [lhsResult, rhsResult]

	def computeInterpolatedCheckpoint(self, t: float) -> SignalValue:
		"""Compute an interpolated checkpoint for the specified time"""
		return SignalValue(t, self.computeInterpolatedValue(t), self.computeInterpolatedDerivative(t))

	# Get the value of a signal at time step t
	def computeInterpolatedValue(self, t: float) -> float:
		"""Compute an interpolated value for the specified time"""
		# Mirror Efficient Robustness paper implementation:
		# A signal value outside of the defined range of the Signal is undefined -- we crash here to avoid undefined behaviour
		if not self.getTimes() or not self.getDefinedTimeInterval().contains(t, closed=True):
			raise RuntimeError("Value outside of defined interval")
		i = self.computeIndexForSmallestTimeAfter(t)
		# Handle exact match
		if self.getTime(i) == t:
			return self.getValue(i)
		# If it's somewhere between two data points, interpolate
		value = self.getValue(i - 1)
		derivative = self.getDerivative(i - 1)
		# fraction of the way the interpolated point is between the point at i-1(0) and i(1)
		fraction = (t - self.getTime(i - 1)) / (self.getTime(i) - self.getTime(i - 1))
		value += derivative * fraction
		# value += (self.getValue(i) - self.getValue(i - 1)
		#           ) / ((self.getTime(i) - self.getTime(i - 1)) * t - self.getTime(i - 1))
		return value

	# Get a derivative of the signal at time step t
	def computeInterpolatedDerivative(self, t: float) -> float:
		"""Compute an interpolated derivative for the specified time.\n
		Following the finite, piecewise, linear, continuous hypothesis,
		this returns the derivative between the values (in self.getTimes()) that t is located between.
		(i.e. self.getDerivative(i) where i is the largest index such that t < self.getTime(i))"""

		return self.getDerivative(self.computeIndexForLargestTimeBefore(t))

	def computeInterval(self, interval: Interval, half_open: bool = False) -> 'Signal':
		""" Find the part of the signal that fits within the specified interval
		 (endpoint inclusion based on value of 'half_open') """
		constructedSignalName = f"{self.getName()}_interval"
		signalType = type(self)
		output: 'Signal' = signalType(constructedSignalName)
		# Handle cases where lower bound is larger or equal to biggest values in the Signal.
		if interval.getLower() > self.getLargestTime():
			return output
		if interval.getLower() == self.getLargestTime():
			output.addCheckpoint(self.checkpoints[-1])
			return output
		# Consider trivial interval case:
		if interval.getUpper() == interval.getLower():
			if not half_open:
				output.addCheckpoint(self.computeInterpolatedCheckpoint(interval.getLower()))
			return output
		# A valid index in the Signal, where timestamp is as close as possible to
		# (but never smaller than) the lower bound of the interval
		lowerBoundIndex = self.computeIndexForSmallestTimeAfter(interval.getLower(), inclusive=True)
		# A valid index in the Signal, where timestamp is as close as possible to
		# (but never larger than or equal to) the upper bound of the interval
		upperBoundIndex = self.computeIndexForLargestTimeBefore(interval.getUpper(), not half_open)

		# Get the output Signal. It might be missing up to two values still:
		#  one at interval.getLower() and one at interval.getUpper()
		output = self.fromCheckpoints(constructedSignalName, self.checkpoints[lowerBoundIndex:upperBoundIndex + 1])
		if interval.getLower() not in self.getTimes() and interval.getLower() > self.getTime(0):
			# If lower bound of the interval isn't included, and does fall within our defined range, compute it
			output.addCheckpoint(self.computeInterpolatedCheckpoint(interval.getLower()))
		if not half_open and interval.getUpper() not in self.getTimes() and interval.getUpper() < self.getTime(-1):
			# If upper bound of the interval isn't included, should be, and falls within our defined range, compute it
			output.addCheckpoint(self.computeInterpolatedCheckpoint(interval.getUpper()))
		return output

	def computeIndexForTime(self, time: float) -> int:
		""" Find the index where 'time' is located. Errors if time not in the current checkpoint list. """
		index = self.times.bisect_left(time)
		assert self.getTime(index) == time, "Can't find an index for a time that isn't in our list."
		return index

	def computeLargestTimeBefore(self, time: float, inclusive: bool = True) -> float:
		""" Return the largest timestamp (specified in a checkpoint),
		smaller than (or equal to, if inclusive is True) the value in the parameter"""
		return self.getTime(self.computeIndexForLargestTimeBefore(time, inclusive))

	def computeIndexForSmallestTimeAfter(self, time: float, inclusive: bool = True) -> int:
		""" Return the index at which the checkpoint with the timestamp closest to
		(but always larger than (or eq iff inclusive)) the given time is """
		assert self.getDefinedTimeInterval().contains(time)
		index = self.times.bisect_left(time)
		if not inclusive and self.getTime(index) == time:
			return index + 1
		return index

	def computeIndexForLargestTimeBefore(self, time: float, inclusive: bool = True) -> int:
		""" Return the index at which the checkpoint with the timestamp closest to
		 (but always smaller than (or eq iff inclusive)) the given time is """
		if time > self.getTime(-1):
			return self.getCheckpointCount() - 1
		if time == self.getTime(-1):
			if inclusive:
				return self.getCheckpointCount() - 1
			return self.getCheckpointCount() - 2
		index = self.times.bisect_left(time)
		if inclusive and self.getTime(index) == time:
			return index
		return index - 1

	def computeSmallestTimeAfter(self, time: float, inclusive: bool = True) -> float:
		"""Get the smallest time (that is specified in a checkpoint) that is larger than
		 (or equal to, if inclusive is True) the value in parameter"""
		# This method can only work if the time is in the interval the Signal is defined over
		return self.getTime(self.computeIndexForSmallestTimeAfter(time, inclusive))

	def oldFormat(self) -> List[List[float]]:
		"""Grab representation of this signal in the format used in old version of the code.
		May be useful to compare outputs between the versions."""
		# Might be useful sometime.
		# pylint: disable=protected-access
		return [self.getTimes()._lists[0], self.getValues(), self.getDerivatives()]

	def computeLines(self) -> List[LineSegment]:
		""" Convert the Signal into a set of LineSegments; used to compute intersections. """
		ret: List[LineSegment] = []
		for i in range(self.getCheckpointCount() - 1):
			cpA: SignalValue = self.getCheckpoint(i)
			cpB: SignalValue = self.getCheckpoint(i + 1)
			ret.append(LineSegment(Point(cpA.getTime(), cpA.getValue()), Point(cpB.getTime(), cpB.getValue())))
		return ret

	def getValues(self) -> List[float]:
		""" Get the values for the signal. """
		return [x.getValue() for x in self.checkpoints]

	def getTimes(self) -> List[float]:
		""" Get the times for the signal. """
		# if not all([x == y for x, y in zip(self.times, [x.getTime() for x in self.checkpoints])]):
		# 	print(self.times)
		# 	print([x.getTime() for x in self.checkpoints])
		# 	raise AssertionError("These two should be equal!")
		return self.times

	def getDerivatives(self) -> List[float]:
		""" Get the derivatives for the signal. """
		return [x.getDerivative() for x in self.checkpoints]

	def getCheckpointCount(self) -> int:
		""" Get the size of the checkpoint list for the signal. """
		return len(self.checkpoints)

	def getCheckpoints(self) -> List[SignalValue]:
		""" Get the list of checkpoints for the signal. """
		return self.checkpoints

	def getName(self) -> str:
		""" Get the name for the signal. """
		return self.name

	def setName(self, name: str) -> None:
		""" Set the Signal's name attribute. """
		self.name = name

	def getSmallestTime(self) -> float:
		""" Return the value of the smallest timestamp (usually 0) """
		# pylint: disable=protected-access
		assert len(self.times._lists) == 1
		return self.times._lists[0][0]
		# pylint: enable=protected-access

	def getLargestTime(self) -> float:
		""" Return the value of the largest timestamp """
		# Returns the checkpoint in self.checkpoints with c.getTime() largest
		# pylint: disable=protected-access
		assert len(self.times._lists) == 1
		return self.times._lists[0][-1]
		# pylint: enable=protected-access

	def getTime(self, index: int) -> float:
		"""Return the timestamp of the signal checkpoint at the specified index"""
		# assert all([x == y for x, y in zip(self.times, [c.getTime() for c in self.checkpoints])])
		#assert len(self.times) == len(self.checkpoints)
		#assert all(x == y for x, y in zip(self.times, [c.getTime() for c in self.checkpoints]))

		# pylint: disable=protected-access
		# listIndex, itemIndex = divmod(index, self.times._load)
		# assert self.times._lists[listIndex][itemIndex] == self.times[index]
		#assert self.times._lists[0][index] == self.times[
		#   index], f"{self.times._lists[0][index]} != {self.times[index]} for i = {index}"
		return self.times._lists[0][index]
		# pylint: enable=protected-access

	def getValue(self, index: int) -> float:
		"""Return the value of the signal checkpoint at the specified index"""
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		# pylint: disable=protected-access
		return self.checkpoints._lists[0][index].getValue()

	def getDerivative(self, index: int) -> float:
		"""Return the derivative of the signal checkpoint at the specified index"""
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		# pylint: disable=protected-access
		return self.checkpoints._lists[0][index].getDerivative()

	def getCheckpoint(self, index: int) -> SignalValue:
		"""Return the signal checkpoint at the specified index"""
		#assert abs(index) < len(self.checkpoints), f"{abs(index)} >= {len(self.checkpoints)}. Access non-existent index."
		# pylint: disable=protected-access
		return self.checkpoints._lists[0][index]

	def setValue(self, index: int, value: float) -> None:
		""" Set the value for the checkpoint at index. """
		# pylint: disable=protected-access
		self.checkpoints._lists[0][index].setValue(value)

	def setDerivative(self, index: int, derivative: float) -> None:
		""" Set the derivative for the checkpoint at index. """
		# pylint: disable=protected-access
		self.checkpoints._lists[0][index].setDerivative(derivative)

	def getDefinedTimeInterval(self) -> Interval:
		""" Returns the Interval of time over which this Signal is defined
		Starts at the first sample point, ends at the last. """
		# Checkpoints are sorted by time, so we can just get this by index.
		if len(self.times) == 0:
			return Interval(0, 0)
		if len(self.times) == 1:
			return Interval(self.getTime(0), self.getTime(0))
		return Interval(self.getTime(0), self.getTime(-1))

	def popCheckpoint(self) -> SignalValue:
		"""Pop the last element from the checkpoint list and return it"""
		self.times.pop()
		return self.checkpoints.pop()

	def addCheckpoint(self, sv: SignalValue) -> None:
		"""Add a checkpoint to the signal. Insertion location is determined by the SignalValue's timestamp"""
		# Use the emplace method to make a copy
		# If we simply .add(sv) we reference the same object, this could cause issues in e.g. the derivative computations
		# where different lists may require different derivatives of the same SignalValue
		self.emplaceCheckpoint(sv.getTime(), sv.getValue(), sv.getDerivative())

	def emplaceCheckpoint(self, time: float, value: float, derivative: float = None) -> None:
		"""Add a (constructed) checkpoint to the signal. Insertion location is determined by the timestamp"""
		if derivative is None:
			derivative = 0
		assert time == round(time, 5)
		# Ensure similar time insert has similar value
		if time in self.times:
			if not math.isclose(self.getValue(self.computeIndexForTime(time)), value, rel_tol=1e-4):
				warnings.warn("Skipped insertion of a duplicate point with differing value.")
			return
		if time == 258.90337:
			time = 258.90337

		self.checkpoints.add(SignalValue(time, value, derivative if derivative is not None else 0))
		self.times.add(time)

	def removeCheckpoint(self, index):
		""" Removes a checkpoint at the specified index from the signal. """
		self.checkpoints.pop(index)
		self.times.pop(index)

	def isEmpty(self) -> bool:
		""" Checks if the Signal is empty (i.e. contains no sample points)."""
		return self.getCheckpointCount() == 0

	def isSingular(self) -> bool:
		""" Returns if the signal is defined by a single sample point. """
		return self.getCheckpointCount() == 1

	def shift(self, offset: float) -> 'Signal':
		"""Take the current timestamps, subtract offset"""
		cp: SignalValue
		newCheckpoints: List[SignalValue] = []
		for cp in self.checkpoints:
			newCheckpoints.append(SignalValue(cp.getTime() + offset, cp.getValue(), cp.getDerivative()))
		return self.fromCheckpoints(f"{self.name}_shift", newCheckpoints)

	def merge(self, other: 'Signal') -> None:
		""" Takes all checkpoints from other and merges them into self.\n
		Requires that the timestamps are not equal for all checkpoints where the checkpoints are not identical. """
		assert all(
		    cp.getTime() not in self.getTimes() or self.getCheckpoint(self.computeIndexForTime(cp.getTime())) == cp
		    for cp in other.getTimes()
		)
		for cp in other.getCheckpoints():
			self.addCheckpoint(cp)

	# def simplify(self):
	# 	""" Remove unnecessary checkpoints from the checkpoints list.\n
	# 	These are checkpoints that convey no additional information;
	# 	if three sequential checkpoints have the same value, the middle one conveys no useful information. """
	# 	i = 0
	# 	while i < self.getCheckpointCount() - 2:
	# 		if self.getValue(i) == self.getValue(i + 1) == self.getValue(i + 2):
	# 			self.removeCheckpoint(i + 1)
	# 			continue
	# 		i += 1

	def recomputeDerivatives(self):
		"""Re-compute the derivatives part of each SignalValue, to make sure it matches the current values."""
		if self.checkpoints:  # no-op if empty list
			for i in range(len(self.checkpoints) - 1):
				valueDiff = self.getValue(i + 1) - self.getValue(i)
				timeDiff = self.getTime(i + 1) - self.getTime(i)
				if timeDiff == 0:
					assert False, "This shouldn't be possible - means we have a double time entry."
				self.setDerivative(i, valueDiff / timeDiff)
			self.setDerivative(-1, 0)

	def __str__(self) -> str:
		ret = ["Signal with the following checkpoint entries: "]
		for cp in self.checkpoints:
			ret.append(f'\t{cp.getTime()} -> <{cp.getValue()}, {cp.getDerivative()}>')
		return '\n'.join(ret)

	def __repr__(self) -> str:
		times, values, derivatives = [], [], []
		for x in self.checkpoints:
			times.append(x.getTime())
			values.append(x.getValue())
			derivatives.append(x.getDerivative())
		return f"Signal('{self.name}', {times.__repr__()}, {values.__repr__()}, {derivatives.__repr__()})"

	def __eq__(self, other: 'Signal') -> bool:
		if not isinstance(self, type(other)) or not isinstance(other, type(self)):
			return False
		if self.name != other.name:
			return False
		if len(self.checkpoints) != len(other.checkpoints):
			return False
		for scp, ocp in zip(self.checkpoints, other.checkpoints):
			if scp != ocp:
				return False
		return True

	def filterTimes(self, times: List[float]) -> 'Signal':
		""" Filters the times in the current signal (no copy), so that all checkpoints
		that do not have cp.t in times are removed from the Signal. 
		
		Used to filter the output from functions to the expected output times. """
		index = 0
		while index < self.getCheckpointCount():
			if self.getTime(index) != times[index]:
				self.removeCheckpoint(index)
			else:
				index += 1

	# pylint: enable=too-many-public-methods
